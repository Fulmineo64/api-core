package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("âŒ Devi specificare almeno una cartella come parametro")
		os.Exit(1)
	}

	fmt.Println("ðŸ”§ Generazione index.go...")

	// Cartelle passate da linea di comando
	targetDirs := os.Args[1:]

	for _, baseDir := range targetDirs {
		dirs := map[string][]string{}

		// Raccogli tutti i file .go per directory, escludendo index.go
		err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
			if err != nil || info.IsDir() {
				return nil
			}
			if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "index.go") {
				return nil
			}

			dir := filepath.Dir(path)
			dirs[dir] = append(dirs[dir], path)
			return nil
		})
		if err != nil {
			panic(err)
		}

		// Processa ogni cartella con file Go
		for dir, files := range dirs {
			var modelControllers []string
			var genericControllers []string
			structs := map[string]bool{}
			methods := map[string]bool{}

			for _, path := range files {
				fset := token.NewFileSet()
				node, err := parser.ParseFile(fset, path, nil, 0)
				if err != nil {
					panic(err)
				}

				// Trova le struct che embed-dano controller.Controller
				for _, decl := range node.Decls {
					genDecl, ok := decl.(*ast.GenDecl)
					if !ok || genDecl.Tok != token.TYPE {
						continue
					}
					for _, spec := range genDecl.Specs {
						typeSpec, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}

						structType, ok := typeSpec.Type.(*ast.StructType)
						if !ok {
							continue
						}

						for _, field := range structType.Fields.List {
							selector, ok := field.Type.(*ast.SelectorExpr)
							if !ok {
								continue
							}
							if ident, ok := selector.X.(*ast.Ident); ok && ident.Name == "controller" && selector.Sel.Name == "Controller" {
								structs[typeSpec.Name.Name] = true
							}
						}
					}
				}

				// Trova i metodi associati alle struct
				for _, decl := range node.Decls {
					funcDecl, ok := decl.(*ast.FuncDecl)
					if !ok || funcDecl.Recv == nil || funcDecl.Name == nil {
						continue
					}

					recvType := ""
					switch expr := funcDecl.Recv.List[0].Type.(type) {
					case *ast.StarExpr:
						if ident, ok := expr.X.(*ast.Ident); ok {
							recvType = ident.Name
						}
					case *ast.Ident:
						recvType = expr.Name
					}

					if structs[recvType] && funcDecl.Name.Name == "Model" {
						methods[recvType] = true
					}
				}
			}

			// Classifica i controller
			for name := range structs {
				if methods[name] {
					modelControllers = append(modelControllers, name)
				} else {
					genericControllers = append(genericControllers, name)
				}
			}

			sort.Strings(modelControllers)
			sort.Strings(genericControllers)

			if len(modelControllers)+len(genericControllers) > 0 {
				// Costruisci index.go
				var sb strings.Builder
				sb.WriteString("// Code generated by gen/index.go. DO NOT EDIT.\n\n")
				sb.WriteString("package " + filepath.Base(dir) + "\n\n")
				sb.WriteString("import \"api_core/controller\"\n\n")
				sb.WriteString("func Register() {\n")
				if len(modelControllers) > 0 {
					sb.WriteString("\tcontroller.RegisterModelControllers(\n")
					for _, name := range modelControllers {
						sb.WriteString(fmt.Sprintf("\t\t&%s{},\n", name))
					}
					sb.WriteString("\t)\n")
				}
				if len(genericControllers) > 0 {
					sb.WriteString("\tcontroller.RegisterControllers(\n")
					for _, name := range genericControllers {
						sb.WriteString(fmt.Sprintf("\t\t&%s{},\n", name))
					}
					sb.WriteString("\t)\n")
				}
				sb.WriteString("}\n")

				// Scrivi index.go nella sottocartella
				indexPath := filepath.Join(dir, "index.go")
				err := os.WriteFile(indexPath, []byte(sb.String()), 0644)
				if err != nil {
					panic(err)
				}
			}
		}
	}

	fmt.Println("âœ… Generazione index.go completata.")
}
